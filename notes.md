#COMMENTS
The server.php script is responsible for initializing the server on the host. It creates an instance of SuttonQuestServer, and specifies  a connection handler for each time a new client connects. When SuttonQuestServer is initialized, a world map is read and built from a text file (which can be modified to increase world size or change the layout). The server then listens for any incoming connections, and spawns a child process (via the aforementioned connection handler), sending it the world class, and a newly created SuttonQuestClient, which the connection handler can then use to send information to the client and request information from the database.

Client-side works using AJAX requests via the request.php script every 2.5 seconds, retrieving world information and updates via JSON, which are then reflected in client. On initial load, the client requests the world state from the server, and draws the map, and updates the room descriptions, etc.

When you connect on the client, your character is chosen from a pool of 10 (which could be easily scaled up), marked as active, and placed in the world. Inactive characters are checked regularly and set as inactive after 1 minute has elapsed, enabling new clients to connect. The chat logic works by adding say commands to a update_queue on the database, this table gets queried by players performing updates, and returns a list of all messages since their last update. I realised after creating this that the original spec required tell and say commands (local to the room), which weren't implemented, but could be easily added by adding additional columns to the update_queue (such as location, or playerID of the player in tell), and then sent via the updates accordingly.

I had planned to create a objective type game, where players are on two teams and attempt to capture objectives, which are denoted by gold squares on the map. Megabeasts would then spawn intermittently, recapturing objectives and fighting players. This is why there is some scaffolding code present in the model.php, and wasn't implemented because of time constraints.

#THINGS TO CONSIDER
Preventing race conditions when scaling up the world size depends on the problem, e.g. if an item spawned in a room of a 100 people, I would implement some sort of logic to lock that item in the server after the first request by a client. i.e. assuming a client -> server -> database approach, the server could lock out further attempts to interact with the item from other players once one player has 'locked it'.

Similarly, by using this approach on the server you could prevent monsters (or players) from being spam attacked by all other players in the room. A player that wanted to attack a monster would request a lock, apply the damage, and then release the lock (allowing other players to attack), similar to how ACID transactions work in a database.

As the number of users increases, over-crowding and general chaos are obvious problems. These could be solved by increasing the world size, as well as scaling up monster difficulty, spawn rates, etc. depending on the number of users. Additionally, depending on the size of the player base, the entire server architecture might require a re-design, perhaps breaking up the game into different areas, and utlising a server for each area.

#ISSUES & CAVEATS
The server's physical location is hosted in Germany, meaning you might get signifcant lag.

If I'd had slightly longer, I would have learned and implemented the server using WebSockets, which allows for low-latency bi-directional communication between a web-browser and a server, which would have eliminated the need for the client browser to request updates every 2.5 seconds.

It would be easy for a player to modify the JSON requests, i.e. changing playerID to another number. This could be solved by using a unique key which is generated by the server, returned to the player on the initial load, then used to authenticate further requests/updates, which would prevent other users from faking any updates.
